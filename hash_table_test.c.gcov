        -:    0:Source:hash_table_test.c
        -:    0:Programs:2
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include "hash_table.h"
        -:    4:#include <stdbool.h>
        -:    5:#include <CUnit/CUnit.h>
        -:    6:#include <CUnit/Basic.h>
        -:    7:#include <string.h>
        -:    8:#define No_Buckets 17
        -:    9:
        -:   10:
function init_suite called 1 returned 100% blocks executed 100%
        1:   11:int init_suite(void)
        1:   11-block  0
        -:   12:{
        1:   13:  return 0;
        1:   13-block  0
unconditional  0 taken 1
        -:   14:}
        -:   15:
function clean_suite called 1 returned 100% blocks executed 100%
        1:   16:int clean_suite(void)
        1:   16-block  0
        -:   17:{
        1:   18:  return 0;
        1:   18-block  0
unconditional  0 taken 1
        -:   19:}
        -:   20:
        -:   21:union elem
        -:   22:{
        -:   23:  /// TODO: update the names of the fields to something better? 
        -:   24:  int i;
        -:   25:  unsigned int u;
        -:   26:  bool b;
        -:   27:  float f;
        -:   28:  void *p;
        -:   29:  //char c;
        -:   30:  char *s;
        -:   31:};
        -:   32:
function get_int_hash_key called 603 returned 100% blocks executed 100%
      603:   33:static int get_int_hash_key(elem_t key){
      603:   33-block  0
      603:   34:  return key.i;
      603:   34-block  0
unconditional  0 taken 603
        -:   35:}
        -:   36:
function int_key_cmp called 352 returned 100% blocks executed 100%
      352:   37:static int int_key_cmp(elem_t a, elem_t b){
      352:   37-block  0
      352:   38:  return a.i - b.i;
      352:   38-block  0
unconditional  0 taken 352
        -:   39:}
        -:   40:
function int_value_cmp called 0 returned 0% blocks executed 0%
    #####:   41:bool int_value_cmp (elem_t a, elem_t b){
    $$$$$:   41-block  0
    #####:   42:  return a.i == b.i;
    $$$$$:   42-block  0
unconditional  0 never executed
        -:   43:}
        -:   44:
function string_value_cmp called 18 returned 100% blocks executed 100%
       18:   45:static bool string_value_cmp(elem_t a, elem_t b){
       18:   45-block  0
       18:   46:  return !strcmp(a.s,b.s);
       18:   46-block  0
unconditional  0 taken 18
        -:   47:}
        -:   48:
function str_key_cmp called 38 returned 100% blocks executed 100%
       38:   49:static int str_key_cmp(elem_t a, elem_t b){
       38:   49-block  0
       38:   50:  return strcmp(a.s,b.s);
       38:   50-block  0
unconditional  0 taken 38
        -:   51:}
        -:   52:
        -:   53:// Will not work so consistent for shorter string keys
function string_sum_hash called 5 returned 100% blocks executed 100%
        5:   54:int string_sum_hash(elem_t string)
        5:   54-block  0
        -:   55:{
        5:   56:  char *str = string.s;
        5:   57:  int result = 0;
        5:   57-block  0
unconditional  0 taken 5
        -:   58:  do
        -:   59:    {
        7:   60:      result += *str;
        -:   61:    }
        7:   62:  while (*++str != '\0');
        7:   62-block  0
branch  0 taken 2
branch  1 taken 5 (fallthrough)
        5:   63:  return result;
        5:   63-block  0
unconditional  0 taken 5
        -:   64:}
        -:   65:
        -:   66://
        -:   67:// Helper function for test_hash_table_all and test_hash_table_any
        -:   68://
        -:   69://Checks if *compare_string" == value
function string_equal called 11 returned 100% blocks executed 100%
       11:   70:static bool string_equal(elem_t key, elem_t value, void *compare_string, ioopm_hash_table_t *ht){
       11:   70-block  0
       11:   71:  elem_t *other_value_ptr = compare_string;
       11:   72:  elem_t other_value = *other_value_ptr;
       11:   73:  return (string_value_cmp(value, other_value));
       11:   73-block  0
call    0 returned 11
unconditional  1 taken 11
        -:   74:}
        -:   75:
        -:   76://
        -:   77:// Helper function for test_hash_table_apply to all
        -:   78://
        -:   79:// Changes *entry = *string_to_insert
function change_value called 4 returned 100% blocks executed 100%
        4:   80:static void change_value(elem_t key, elem_t *entry, void *string_to_insert)
        4:   80-block  0
        -:   81:{
        -:   82:  // change the value of the entry
        4:   83:  elem_t *string_to_insert_ptr = string_to_insert;
        4:   84:  elem_t string = *string_to_insert_ptr;
        4:   85:  *entry = string;
        4:   86:}
        -:   87:
function test_create_and_destroy called 1 returned 100% blocks executed 100%
        1:   88:void test_create_and_destroy(void)
        1:   88-block  0
        -:   89:{
        -:   90:  // Int-based hash-keys
        1:   91:  ioopm_hash_table_t* ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:   91-block  0
call    0 returned 1
        1:   92:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        -:   93:
        -:   94:  // String-based hash-keys
        1:   95:  ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
call    0 returned 1
        1:   96:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:   97:}
        -:   98:
function test_insert called 1 returned 100% blocks executed 100%
        1:   99:void test_insert(void){
        1:   99-block  0
        1:  100:    ioopm_hash_table_t* ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  100-block  0
call    0 returned 1
        1:  101:    char *value[No_Buckets] = {"a","b","c","d","e","f","g","h","i","j","k","l","n","o","p","q"};
        -:  102:    
       18:  103:    for (int i = 0; i < No_Buckets; i++)
unconditional  0 taken 1
unconditional  1 taken 17
       18:  103-block  0
branch  2 taken 17
branch  3 taken 1 (fallthrough)
        -:  104:    {
       17:  105:        ioopm_hash_table_insert(ht,int_elem(i),str_elem(value[i]));
       17:  105-block  0
call    0 returned 17
        -:  106:    }
        1:  107:    ioopm_hash_table_destroy(ht);
        1:  107-block  0
call    0 returned 1
        1:  108:}
        -:  109:
function test_insert_lookup_int called 1 returned 100% blocks executed 100%
        1:  110:void test_insert_lookup_int(void)
        1:  110-block  0
        -:  111:{ 
        -:  112:    // Test for int hash
        1:  113:    ioopm_hash_table_t* ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  113-block  0
call    0 returned 1
        1:  114:    char *value[No_Buckets] = {"a","b","c","d","e","f","g","h","i","j","k","l","n","o","p","q"};
        1:  115:    bool success = false;
       18:  116:    for (int i = 0; i < No_Buckets; i++)
unconditional  0 taken 1
unconditional  1 taken 17
       18:  116-block  0
branch  2 taken 17
branch  3 taken 1 (fallthrough)
        -:  117:    {
       17:  118:        ioopm_hash_table_insert(ht,int_elem(i),str_elem(value[i]));
       17:  118-block  0
call    0 returned 17
        -:  119:    }
       18:  120:    for (int i = 0; i < No_Buckets; i++)
        1:  120-block  0
unconditional  0 taken 1
unconditional  1 taken 17
       18:  120-block  1
branch  2 taken 17
branch  3 taken 1 (fallthrough)
        -:  121:    {
       17:  122:        ioopm_hash_table_lookup(ht,int_elem(i),&success);
       17:  122-block  0
call    0 returned 17
       17:  123:        CU_ASSERT(success);
call    0 returned 17
        -:  124:    }
        -:  125:
        1:  126:    ioopm_hash_table_destroy(ht);
        1:  126-block  0
call    0 returned 1
        1:  127:}
        -:  128:
        -:  129:
function test_insert_lookup_str called 1 returned 100% blocks executed 100%
        1:  130:void test_insert_lookup_str(void){
        1:  130-block  0
        1:  131:    ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, int_value_cmp, str_key_cmp);
        1:  131-block  0
call    0 returned 1
        1:  132:    char *keys[No_Buckets] = {"a","b","c","d","e","f","g","h","i","j","k","l","n","o","p","q"};
        1:  133:    bool success = false;
       17:  134:    for (int i = 0; i<16; i++)
unconditional  0 taken 1
unconditional  1 taken 16
       17:  134-block  0
branch  2 taken 16
branch  3 taken 1 (fallthrough)
        -:  135:    {
       16:  136:      ioopm_hash_table_insert(ht,str_elem(keys[i]), int_elem(i));
       16:  136-block  0
call    0 returned 16
        -:  137:    }
       17:  138:    for (int i = 0; i < 16; i++)
        1:  138-block  0
unconditional  0 taken 1
unconditional  1 taken 16
       17:  138-block  1
branch  2 taken 16
branch  3 taken 1 (fallthrough)
        -:  139:    {
       16:  140:        ioopm_hash_table_lookup(ht,str_elem(keys[i]),&success);
       16:  140-block  0
call    0 returned 16
       16:  141:        CU_ASSERT(success);
call    0 returned 16
        -:  142:    }
        1:  143:    ioopm_hash_table_destroy(ht);
        1:  143-block  0
call    0 returned 1
        1:  144:}
        -:  145:
function test_char_for_keys called 1 returned 100% blocks executed 100%
        1:  146:void test_char_for_keys(void){
        1:  146-block  0
        1:  147:  ioopm_hash_table_t* ht = ioopm_hash_table_create(string_sum_hash, int_value_cmp, str_key_cmp);
        1:  147-block  0
call    0 returned 1
        1:  148:  bool success = true;
        1:  149:  ioopm_hash_table_lookup(ht, str_elem("a"), &success);
call    0 returned 1
        1:  150:  CU_ASSERT_FALSE(success);
call    0 returned 1
        -:  151:  //Check value that does not exist in a non emmpty list
        1:  152:    ioopm_hash_table_insert(ht,str_elem("a"),int_elem(-1));
call    0 returned 1
        1:  153:    ioopm_hash_table_lookup(ht,str_elem("b"),&success);
call    0 returned 1
        1:  154:    CU_ASSERT_FALSE(success);
call    0 returned 1
        1:  155:    int value = ioopm_hash_table_lookup(ht,str_elem("a"), &success).i;
call    0 returned 1
        1:  156:    CU_ASSERT_EQUAL(value,-1);
call    0 returned 1
        1:  157:    CU_ASSERT(success);
call    0 returned 1
        1:  158:    ioopm_hash_table_lookup(ht,str_elem("hej"), &success);
call    0 returned 1
        1:  159:    CU_ASSERT_FALSE(success);
call    0 returned 1
        1:  160:    ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  161:}
        -:  162:
function test_lookup called 1 returned 100% blocks executed 100%
        1:  163:void test_lookup(void){
        1:  163-block  0
        1:  164:    ioopm_hash_table_t* ht = ioopm_hash_table_create(get_int_hash_key,string_value_cmp, int_key_cmp);
        1:  164-block  0
call    0 returned 1
        1:  165:    bool success=true;
        -:  166:    //Check value in an empty hash table
        1:  167:    ioopm_hash_table_lookup(ht,int_elem(16),&success);
call    0 returned 1
        1:  168:    CU_ASSERT_FALSE(success);
call    0 returned 1
        -:  169:
        -:  170:    //Check value that does not exist in a non emmpty list
        1:  171:    ioopm_hash_table_insert(ht,int_elem(-1),str_elem("a"));
call    0 returned 1
        1:  172:    ioopm_hash_table_lookup(ht,int_elem(16),&success);
call    0 returned 1
        1:  173:    CU_ASSERT_FALSE(success);
call    0 returned 1
        1:  174:    ioopm_hash_table_lookup(ht,int_elem(1), &success);
call    0 returned 1
        1:  175:    CU_ASSERT_FALSE(success);
call    0 returned 1
        -:  176:
        -:  177:    //Check value in a list of size 1;
        1:  178:    CU_ASSERT_STRING_EQUAL((ioopm_hash_table_lookup(ht,int_elem(-1), &success)).s, "a");
call    0 returned 1
call    1 returned 1
        1:  179:    CU_ASSERT(success);
call    0 returned 1
        1:  180:    ioopm_hash_table_lookup(ht,int_elem(1), &success);
call    0 returned 1
        1:  181:    CU_ASSERT_FALSE(success);
call    0 returned 1
        -:  182:
        -:  183:    //Check values in the middle and last in a bucket
        1:  184:    ioopm_hash_table_insert(ht,int_elem(16),str_elem("b"));
call    0 returned 1
        1:  185:    ioopm_hash_table_insert(ht,int_elem(33),str_elem(NULL));
call    0 returned 1
        -:  186:
        1:  187:    CU_ASSERT_STRING_EQUAL(ioopm_hash_table_lookup(ht,int_elem(16), &success).s,"b");
call    0 returned 1
call    1 returned 1
        1:  188:    CU_ASSERT(success);
call    0 returned 1
        -:  189:
        1:  190:    ioopm_hash_table_lookup(ht,int_elem(50),&success);
call    0 returned 1
        1:  191:    CU_ASSERT_FALSE(success);
call    0 returned 1
        -:  192:
        1:  193:    ioopm_hash_table_lookup(ht,int_elem(33), &success);
call    0 returned 1
        1:  194:    CU_ASSERT(success);
call    0 returned 1
        -:  195:    
        1:  196:    ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  197:}
        -:  198:
        -:  199:
function test_remove called 1 returned 100% blocks executed 100%
        1:  200:void test_remove(void){
        1:  200-block  0
        1:  201:    ioopm_hash_table_t* ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  201-block  0
call    0 returned 1
        1:  202:    bool success = true;
        -:  203:    //check removal av icke-existerande entry i tom ht
        1:  204:    CU_ASSERT_PTR_NULL(ioopm_hash_table_remove(ht,int_elem(5), &success).s);
call    0 returned 1
call    1 returned 1
        1:  205:    CU_ASSERT_FALSE(success);
call    0 returned 1
        -:  206:
        1:  207:    ioopm_hash_table_insert(ht,int_elem(1),str_elem("b"));
call    0 returned 1
        1:  208:    ioopm_hash_table_insert(ht,int_elem(-16),str_elem("a"));
call    0 returned 1
        1:  209:    ioopm_hash_table_insert(ht,int_elem(18),str_elem("c"));
call    0 returned 1
        -:  210:    
        -:  211:  
        -:  212:    //check removal i mitten
        1:  213:    CU_ASSERT_STRING_EQUAL(ioopm_hash_table_remove(ht,int_elem(1), &success).s, "b"); 
call    0 returned 1
call    1 returned 1
        1:  214:    CU_ASSERT(success);
call    0 returned 1
        -:  215:
        -:  216:    //check removal i början
        1:  217:    CU_ASSERT_STRING_EQUAL(ioopm_hash_table_remove(ht,int_elem(-16), &success).s, "a"); 
call    0 returned 1
call    1 returned 1
        1:  218:    CU_ASSERT(success);
call    0 returned 1
        -:  219:
        -:  220:    //check removal i slutet
        1:  221:    CU_ASSERT_STRING_EQUAL(ioopm_hash_table_remove(ht,int_elem(18), &success).s, "c"); 
call    0 returned 1
call    1 returned 1
        1:  222:    CU_ASSERT(success);
call    0 returned 1
        -:  223:
        -:  224:    //check removal av icke-existerande entry som har funnits
        1:  225:    CU_ASSERT_PTR_NULL(ioopm_hash_table_remove(ht,int_elem(1), &success).s);
call    0 returned 1
call    1 returned 1
        1:  226:    CU_ASSERT_FALSE(success);
call    0 returned 1
        -:  227:
        1:  228:    ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  229:}
        -:  230:
        -:  231:
function test_hashtable_size called 1 returned 100% blocks executed 100%
        1:  232:void test_hashtable_size(){
        1:  232-block  0
        1:  233:  ioopm_hash_table_t* ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  233-block  0
call    0 returned 1
        -:  234:  //Check empty hash table
        1:  235:  CU_ASSERT(ioopm_hash_table_size(ht)==0);
call    0 returned 1
call    1 returned 1
        -:  236:
        -:  237:  //Check hash table of one element
        1:  238:  ioopm_hash_table_insert(ht,int_elem(1),str_elem("a"));
call    0 returned 1
        1:  239:  CU_ASSERT(ioopm_hash_table_size(ht)==1);
call    0 returned 1
call    1 returned 1
        -:  240:
        -:  241:  //Check size after inserting multiple elements
        1:  242:  ioopm_hash_table_insert(ht,int_elem(-16),str_elem("b"));
call    0 returned 1
        1:  243:  ioopm_hash_table_insert(ht,int_elem(18),str_elem("c"));
call    0 returned 1
        1:  244:  CU_ASSERT(ioopm_hash_table_size(ht)==3);
call    0 returned 1
call    1 returned 1
        -:  245:
        -:  246:  // Check size after inserting a key that already exists
        1:  247:  ioopm_hash_table_insert(ht,int_elem(1),str_elem("a"));
call    0 returned 1
        1:  248:  CU_ASSERT(ioopm_hash_table_size(ht)==3);
call    0 returned 1
call    1 returned 1
        -:  249:
        -:  250:  // Check size after inserting multiple keys that already exists
        1:  251:  ioopm_hash_table_insert(ht,int_elem(-16),str_elem("b"));
call    0 returned 1
        1:  252:  ioopm_hash_table_insert(ht,int_elem(18),str_elem("c"));
call    0 returned 1
        1:  253:  CU_ASSERT(ioopm_hash_table_size(ht)==3);
call    0 returned 1
call    1 returned 1
        -:  254:
        -:  255:  // Check size after clearing all elements in hashtable
        1:  256:  ioopm_hash_table_clear(ht);
call    0 returned 1
        1:  257:  CU_ASSERT(ioopm_hash_table_size(ht)==0);
call    0 returned 1
call    1 returned 1
        -:  258:
        1:  259: ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  260:}
        -:  261:
function test_is_empty called 1 returned 100% blocks executed 100%
        1:  262:void test_is_empty(){
        1:  262-block  0
        1:  263:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  263-block  0
call    0 returned 1
        -:  264:  //Check hash empty table
        1:  265:  CU_ASSERT(ioopm_hash_table_is_empty(ht));
call    0 returned 1
call    1 returned 1
        -:  266:
        -:  267:  //Check hash table with one element
        1:  268:  ioopm_hash_table_insert(ht,int_elem(-16),str_elem("b"));
call    0 returned 1
        1:  269:  CU_ASSERT_FALSE(ioopm_hash_table_is_empty(ht));
call    0 returned 1
call    1 returned 1
        -:  270:  
        -:  271:  //Check hash table after clearing all elements
        1:  272:  ioopm_hash_table_insert(ht,int_elem(-13),str_elem("c"));
call    0 returned 1
        1:  273:  ioopm_hash_table_clear(ht);
call    0 returned 1
        1:  274:  CU_ASSERT(ioopm_hash_table_is_empty(ht));
call    0 returned 1
call    1 returned 1
        -:  275:
        1:  276:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  277:}
        -:  278:
        -:  279:
function test_clear called 1 returned 100% blocks executed 100%
        1:  280:void test_clear(){
        1:  280-block  0
        1:  281:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  281-block  0
call    0 returned 1
        -:  282:  //Check clear of empty hash table
        1:  283:  ioopm_hash_table_clear(ht);
call    0 returned 1
        1:  284:  CU_ASSERT(ioopm_hash_table_is_empty(ht));
call    0 returned 1
call    1 returned 1
        -:  285:
        -:  286:  //Chekc clear after inserting elements
        1:  287:  ioopm_hash_table_insert(ht,int_elem(1),str_elem("a"));
call    0 returned 1
        1:  288:  ioopm_hash_table_clear(ht);
call    0 returned 1
        1:  289:  CU_ASSERT(ioopm_hash_table_is_empty(ht));
call    0 returned 1
call    1 returned 1
        -:  290:  
        1:  291:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  292:}
        -:  293:
function test_table_keys called 1 returned 100% blocks executed 100%
        1:  294:void test_table_keys(){
        1:  294-block  0
        1:  295:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  295-block  0
call    0 returned 1
        -:  296:  
        -:  297:  // Test creating a list when no keys exists
        1:  298:  ioopm_list_t *keys = ioopm_hash_table_keys(ht);
call    0 returned 1
        1:  299:  CU_ASSERT_EQUAL(ioopm_linked_list_size(keys), 0);
call    0 returned 1
call    1 returned 1
        1:  300:  ioopm_linked_list_destroy(keys);
call    0 returned 1
        -:  301:  
        -:  302:  
        -:  303:  // Test creating a list when keys do exist
        1:  304:  ioopm_hash_table_insert(ht,int_elem(10),str_elem("a"));
call    0 returned 1
        1:  305:  keys = ioopm_hash_table_keys(ht);
call    0 returned 1
        1:  306:  size_t key_amount = 1;
        1:  307:  CU_ASSERT_EQUAL(ioopm_linked_list_size(keys), key_amount);
call    0 returned 1
call    1 returned 1
        1:  308:  CU_ASSERT_EQUAL(ioopm_linked_list_get(keys,0).s,10);
call    0 returned 1
call    1 returned 1
        -:  309:
        1:  310:  ioopm_linked_list_destroy(keys);
call    0 returned 1
        -:  311:  
        1:  312:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  313:}
        -:  314:
        -:  315:
function test_table_values called 1 returned 100% blocks executed 100%
        1:  316:void test_table_values(){
        1:  316-block  0
        1:  317:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  317-block  0
call    0 returned 1
        -:  318:  
        -:  319:  //Test for an empty hash table
        1:  320:  ioopm_list_t *values = ioopm_hash_table_values(ht);
call    0 returned 1
        1:  321:  CU_ASSERT_EQUAL(ioopm_linked_list_size(values), 0);
call    0 returned 1
call    1 returned 1
        1:  322:  ioopm_linked_list_destroy(values);
call    0 returned 1
        -:  323:    
        -:  324:  // Test non-empty hash table
        1:  325:  ioopm_hash_table_insert(ht,int_elem(10),str_elem("a"));
call    0 returned 1
        1:  326:  values = ioopm_hash_table_values(ht);
call    0 returned 1
        -:  327:  
        1:  328:  CU_ASSERT_EQUAL(ioopm_linked_list_size(values), 1);
call    0 returned 1
call    1 returned 1
        1:  329:  CU_ASSERT_EQUAL(ioopm_linked_list_get(values,0).s,"a");
call    0 returned 1
call    1 returned 1
        1:  330:  ioopm_linked_list_destroy(values);
call    0 returned 1
        -:  331:
        1:  332:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  333:}
        -:  334:
        -:  335:
function test_has_key called 1 returned 100% blocks executed 100%
        1:  336:void test_has_key(){
        1:  336-block  0
        1:  337:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  337-block  0
call    0 returned 1
        -:  338:  
        -:  339:  // Check before inserts 
        1:  340:  bool test = ioopm_hash_table_has_key(ht,int_elem(10));
call    0 returned 1
        1:  341:  CU_ASSERT_FALSE(test);
call    0 returned 1
        -:  342:
        -:  343:  // Check after inserts
        1:  344:  ioopm_hash_table_insert(ht, int_elem(17), str_elem("abc"));
call    0 returned 1
        1:  345:  test = ioopm_hash_table_has_key(ht,int_elem(17));
call    0 returned 1
        1:  346:  CU_ASSERT(test);
call    0 returned 1
        1:  347:  ioopm_hash_table_insert(ht, int_elem(34), str_elem("abc"));
call    0 returned 1
        1:  348:  test = ioopm_hash_table_has_key(ht,int_elem(34));
call    0 returned 1
        1:  349:  CU_ASSERT(test);
call    0 returned 1
        -:  350:  
        1:  351:  bool success = false;
        -:  352:  // Check after removal
        1:  353:  ioopm_hash_table_remove(ht, int_elem(17), &success);
call    0 returned 1
        1:  354:  CU_ASSERT(success);
call    0 returned 1
        1:  355:  test = ioopm_hash_table_has_key(ht,int_elem(17));
call    0 returned 1
        1:  356:  CU_ASSERT_FALSE(test);
call    0 returned 1
        -:  357:
        -:  358:  // Check after clear
        1:  359:  ioopm_hash_table_clear(ht);
call    0 returned 1
        1:  360:  test = ioopm_hash_table_has_key(ht,int_elem(34));
call    0 returned 1
        1:  361:  CU_ASSERT_FALSE(test);
call    0 returned 1
        -:  362:
        1:  363:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  364:}
        -:  365:
        -:  366:
        -:  367:
function test_has_value called 1 returned 100% blocks executed 100%
        1:  368:void test_has_value(){
        1:  368-block  0
        1:  369:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  369-block  0
call    0 returned 1
        -:  370:  //test empty ht
        1:  371:  bool test = ioopm_hash_table_has_value(ht,str_elem("abc"));
call    0 returned 1
        1:  372:  CU_ASSERT_FALSE(test);
call    0 returned 1
        -:  373:
        -:  374:  //test one element ht
        1:  375:  ioopm_hash_table_insert(ht, int_elem(17), str_elem("a"));
call    0 returned 1
        1:  376:  test = ioopm_hash_table_has_value(ht,str_elem("a"));
call    0 returned 1
        1:  377:  CU_ASSERT(test);
call    0 returned 1
        -:  378:
        -:  379:  //test multipe element ht
        1:  380:  ioopm_hash_table_insert(ht, int_elem(34), str_elem("b"));
call    0 returned 1
        -:  381:
        1:  382:  elem_t test_string = str_elem("b");
        -:  383:  //elem_t target = ioopm_strdup(test_string);
        1:  384:  test = ioopm_hash_table_has_value(ht,str_elem("b"));
call    0 returned 1
        1:  385:  CU_ASSERT(test);
call    0 returned 1
        1:  386:  test = ioopm_hash_table_has_value(ht,test_string);
call    0 returned 1
        1:  387:  CU_ASSERT(test);
call    0 returned 1
        -:  388:  
        -:  389:  //test value that does not exist in a multipe element ht
        1:  390:  test = ioopm_hash_table_has_value(ht,str_elem("abc"));
call    0 returned 1
        1:  391:  CU_ASSERT_FALSE(test);
call    0 returned 1
        -:  392:
        1:  393:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        -:  394:
        1:  395:}
        -:  396:
function test_hash_table_all called 1 returned 100% blocks executed 100%
        1:  397:void test_hash_table_all(){
        1:  397-block  0
        1:  398:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  398-block  0
call    0 returned 1
        1:  399:  elem_t test_string = str_elem("a");
        -:  400:  //empty table
        1:  401:  CU_ASSERT_FALSE(ioopm_hash_table_all(ht, string_equal, &test_string));
call    0 returned 1
call    1 returned 1
        -:  402:  //all values the same
        1:  403:  ioopm_hash_table_insert(ht, int_elem(17), str_elem("a"));
call    0 returned 1
        1:  404:  ioopm_hash_table_insert(ht, int_elem(34), str_elem("a"));
call    0 returned 1
        1:  405:  ioopm_hash_table_insert(ht, int_elem(3), str_elem("a"));
call    0 returned 1
        1:  406:  CU_ASSERT(ioopm_hash_table_all(ht, string_equal, &test_string));
call    0 returned 1
call    1 returned 1
        -:  407:  //different values
        1:  408:  ioopm_hash_table_insert(ht, int_elem(20), str_elem("b"));
call    0 returned 1
        1:  409:  ioopm_hash_table_insert(ht, int_elem(51), str_elem("b"));
call    0 returned 1
        1:  410:  CU_ASSERT_FALSE(ioopm_hash_table_all(ht, string_equal, &test_string));
call    0 returned 1
call    1 returned 1
        -:  411:
        1:  412:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  413:}
        -:  414:
function test_apply_to_all called 1 returned 100% blocks executed 100%
        1:  415:void test_apply_to_all(){
        1:  415-block  0
        1:  416:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  416-block  0
call    0 returned 1
        1:  417:  elem_t string = str_elem("kalas");
        -:  418:  //test apply to empty list
        1:  419:  ioopm_hash_table_apply_to_all(ht,change_value,&string);
call    0 returned 1
        1:  420:  CU_ASSERT_FALSE(ioopm_hash_table_all(ht, string_equal, &string));
call    0 returned 1
call    1 returned 1
        -:  421:  //different values
        1:  422:  ioopm_hash_table_insert(ht, int_elem(-17), str_elem("a"));
call    0 returned 1
        1:  423:  ioopm_hash_table_insert(ht, int_elem(0),str_elem("b"));
call    0 returned 1
        1:  424:  ioopm_hash_table_insert(ht, int_elem(17), str_elem("c"));
call    0 returned 1
        1:  425:  ioopm_hash_table_insert(ht, int_elem(34), str_elem("d"));
call    0 returned 1
        1:  426:  CU_ASSERT_FALSE(ioopm_hash_table_all(ht, string_equal, &string));
call    0 returned 1
call    1 returned 1
        -:  427:  //apply same string and test
        1:  428:  ioopm_hash_table_apply_to_all(ht,change_value,&string);
call    0 returned 1
        1:  429:  CU_ASSERT(ioopm_hash_table_all(ht, string_equal, &string));
call    0 returned 1
call    1 returned 1
        -:  430:
        1:  431:  ioopm_hash_table_destroy(ht);
call    0 returned 1
        1:  432:}
        -:  433:
function test_growing_buckets called 1 returned 100% blocks executed 100%
        1:  434:void test_growing_buckets(){
        1:  434-block  0
        1:  435:  ioopm_hash_table_t *ht = ioopm_hash_table_create(get_int_hash_key, string_value_cmp, int_key_cmp);
        1:  435-block  0
call    0 returned 1
        -:  436:  
        -:  437:  
        -:  438:  // Add 10 elements and check that buckets has not increased from initial size of 17
        -:  439:  
       11:  440:  for (int i = 0; i<10; i++)
unconditional  0 taken 1
unconditional  1 taken 10
       11:  440-block  0
branch  2 taken 10
branch  3 taken 1 (fallthrough)
        -:  441:  {
       10:  442:    ioopm_hash_table_insert(ht,int_elem(i), str_elem("bucket_test"));
       10:  442-block  0
call    0 returned 10
        -:  443:  }
        1:  444:  size_t size_test = 17;
        1:  445:  CU_ASSERT_EQUAL(ioopm_hash_table_capacity(ht), size_test);
        1:  445-block  0
call    0 returned 1
call    1 returned 1
        -:  446:
        -:  447:  
        -:  448:  // Add 5 additional element to check that passing threshold 12.5 has increased buckets size to 31
        6:  449:  for (int i = 10; i<15; i++)
unconditional  0 taken 1
unconditional  1 taken 5
        6:  449-block  0
branch  2 taken 5
branch  3 taken 1 (fallthrough)
        -:  450:  {
        5:  451:    ioopm_hash_table_insert(ht,int_elem(i), str_elem("bucket_test_threshold"));
        5:  451-block  0
call    0 returned 5
        -:  452:  }
        1:  453:  size_test = 31;
        1:  454:  CU_ASSERT_EQUAL(ioopm_hash_table_capacity(ht), size_test);
        1:  454-block  0
call    0 returned 1
call    1 returned 1
        -:  455:
       16:  456:  for(int i = 0; i<15; i++){
unconditional  0 taken 1
unconditional  1 taken 15
       16:  456-block  0
branch  2 taken 15
branch  3 taken 1 (fallthrough)
       15:  457:    bool success = false;
       15:  458:    ioopm_hash_table_lookup(ht,int_elem(i),&success);
       15:  458-block  0
call    0 returned 15
       15:  459:    CU_ASSERT(success);
call    0 returned 15
        -:  460:  }
        -:  461:
        -:  462:  // Add 100 additional element to check increased buckets size to 127
      101:  463:  for (int i = 15; i<115; i++)
        1:  463-block  0
unconditional  0 taken 1
unconditional  1 taken 100
      101:  463-block  1
branch  2 taken 100
branch  3 taken 1 (fallthrough)
        -:  464:  {
      100:  465:    ioopm_hash_table_insert(ht,int_elem(i), str_elem("bucket_test_threshold"));
      100:  465-block  0
call    0 returned 100
        -:  466:  }
        1:  467:  size_test = 127;
        -:  468:
      116:  469:  for(int i = 0; i<115; i++){
        1:  469-block  0
unconditional  0 taken 1
unconditional  1 taken 115
      116:  469-block  1
branch  2 taken 115
branch  3 taken 1 (fallthrough)
      115:  470:    bool success = false;
      115:  471:    ioopm_hash_table_lookup(ht,int_elem(i),&success);
      115:  471-block  0
call    0 returned 115
      115:  472:    CU_ASSERT(success);
call    0 returned 115
        -:  473:  }
        -:  474:
        1:  475:  ioopm_hash_table_destroy(ht);
        1:  475-block  0
call    0 returned 1
        1:  476:}
        -:  477:
function main called 1 returned 100% blocks executed 85%
        1:  478:int main()
        1:  478-block  0
        -:  479:{
        1:  480:  CU_pSuite test_suite1 = NULL;
        -:  481:
        1:  482:  if (CUE_SUCCESS != CU_initialize_registry())
        1:  482-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  483:    return CU_get_error();
    $$$$$:  483-block  0
call    0 never executed
unconditional  1 never executed
        -:  484:
        1:  485:  test_suite1 = CU_add_suite("Test Suite 1", init_suite, clean_suite);
        1:  485-block  0
call    0 returned 1
        1:  486:  if (NULL == test_suite1)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  487:    {
    #####:  488:      CU_cleanup_registry();
    $$$$$:  488-block  0
call    0 never executed
    #####:  489:      return CU_get_error();
call    0 never executed
unconditional  1 never executed
        -:  490:    }
        -:  491:
        1:  492:  if (
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        2:  493:    (NULL == CU_add_test(test_suite1, "test 1: test char for keys",test_char_for_keys)) ||
        1:  493-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  494:    (NULL == CU_add_test(test_suite1, "test 2: table create and destroy", test_create_and_destroy)) ||
        1:  494-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  495:    (NULL == CU_add_test(test_suite1, "test 3: insert", test_insert)) || 
        1:  495-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  496:    (NULL == CU_add_test(test_suite1, "test 4: remove", test_remove)) ||
        1:  496-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  497:    (NULL == CU_add_test(test_suite1, "test 5: hash size", test_hashtable_size)) ||
        1:  497-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  498:    (NULL == CU_add_test(test_suite1, "test 6: is empty", test_is_empty)) ||
        1:  498-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  499:    (NULL == CU_add_test(test_suite1, "test 7: clear", test_clear)) ||
        1:  499-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  500:    (NULL == CU_add_test(test_suite1, "test 8: linked list keys", test_table_keys)) ||
        1:  500-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  501:    (NULL == CU_add_test(test_suite1, "test 9: linked list values", test_table_values)) || 
        1:  501-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  502:    (NULL == CU_add_test(test_suite1, "test 10: has key",test_has_key)) ||
        1:  502-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  503:    (NULL == CU_add_test(test_suite1, "test 11: has value", test_has_value)) ||
        1:  503-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  504:    (NULL == CU_add_test(test_suite1, "test 12: all",test_hash_table_all)) ||
        1:  504-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  505:    (NULL == CU_add_test(test_suite1, "test 13: apply all",test_apply_to_all))||
        1:  505-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  506:    (NULL == CU_add_test(test_suite1, "test 14: insert", test_insert_lookup_int)) ||
        1:  506-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  507:    (NULL == CU_add_test(test_suite1, "test 15: insert", test_insert_lookup_str)) ||  
        1:  507-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        2:  508:    (NULL == CU_add_test(test_suite1, "test 16: lookup", test_lookup)) ||
        1:  508-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        1:  509:    (NULL == CU_add_test(test_suite1, "test 17: growing bucket", test_growing_buckets)) 
        1:  509-block  0
call    0 returned 1
        -:  510:
        -:  511:    )
        -:  512:    {
    #####:  513:      CU_cleanup_registry();
    $$$$$:  513-block  0
call    0 never executed
    #####:  514:      return CU_get_error();
call    0 never executed
unconditional  1 never executed
        -:  515:    }
        -:  516:
        1:  517:  CU_basic_set_mode(CU_BRM_VERBOSE);
        1:  517-block  0
call    0 returned 1
        1:  518:  CU_basic_run_tests();
call    0 returned 1
        1:  519:  CU_cleanup_registry();
call    0 returned 1
        1:  520:  return CU_get_error();
call    0 returned 1
unconditional  1 taken 1
        -:  521:}
